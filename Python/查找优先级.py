class Person(object):
    def __call__(self, *args, **kwargs):
        print(self.name, '__call__')

    def __init__(self, name, age):
        self.name = name
        self.age = age
        print(self.name, '__init__')

    def __del__(self):
        print(self.name, '__del__')

    def __str__(self):
        print(self.name, '__str__')
        return '%s: %d' % (self.name, self.age)

print('--------实例化对象-----------')
p = Person('Tom', 18)
print('--------打印实例对象-----------')
print(p)
print('--------把实例对象作为方法进行调用-----------')
p()  # 等价于 Person('Tom', 18)()
print('--------程序运行结束-----------')


"""
__doc__ 类的描述信息
__module__  表示当前操作的对象对应的类的定义所在的模块名
__class__   表示当前操作的对象对应的类名
__dict__    一个字典，保存类的所有的成员（包括属性和方法）或实例对象中的所有成员属性

在Python 3.x中无论是否显示指定继承object，所有的类都是新式类，那么我们根据上面的两个实例的输出结果可以得出这样的结论：在多继承的情况下，经典类查找父类属性或方法的顺序是深度优先，新式类查找父类属性的顺序是广度优先。
深度优先 可以理解为 纵向优先，广度优先 可以理解为水平方法优先。我们知道，类与类之间是有层级关系的，父类与子类是纵向的层级关系，同一个父类的多个直接子类是水平方向的同级关系。

 A是父类、B和C是继承A的子类，D是同时继承B和C的子类。此时D的一个实例对象去查找一个父类中的属性或方法的查找顺序就有两种可能，
 但是这两种查找顺序中第一个查找的父类必然都是B：
B-->A-->C：这就是深度优先，因为优先查找的是与B上一层级的、纵向的A
B-->C-->A：这就是广度优先，因为优先查找的是与B同一层极的、水平方向的C


.key
秘钥文件
.csr
证书申请文件
.crt
证书文件
.p12
证书文件导出的PKCS12格式，在配置web服务器的时候需要用到


"""
